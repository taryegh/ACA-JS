//////////////////////////////////////////////////////////////
There are 7 basic data types in JavaScript.

- number for numbers of any kind: integer or floating-point.
- string for strings. A string may have one or more characters, there’s no separate single-character type.
- boolean for true/false.
- null for unknown values – a standalone type that has a single value null.
- undefined for unassigned values – a standalone type that has a single value undefined.
- object for more complex data structures.
- symbol for unique identifiers.



//////////////////////////////////////////////////////////////

typeof undefined // "undefined"

typeof 0 // "number"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)



//////////////////////////////////////////////////////////////

typeof Number
"function"

typeof Number()
"number"

typeof Object
"function"

typeof Function
"function"

typeof String
"function"





//////////////////////////////////////////////////////////////

alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
Please note that null and undefined behave differently here: null becomes zero while undefined becomes NaN.




//////////////////////////////////////////////////////////////


Almost all mathematical operations convert values to numbers. A notable exception is addition +. If one of the added values is a string, the other one is also converted to a string.

Then, it concatenates (joins) them:

alert( 1 + '2' ); // '12' (string to the right)
alert( '1' + 2 ); // '12' (string to the left)

This only happens when at least one of the arguments is a string. Otherwise, values are converted to numbers.


//////////////////////////////////////////////////////////////


ToNumber

Value -	      Becomes…
undefined	    NaN
null	        0
true / false	1 / 0
string	The string is read “as is”, whitespaces from both sides are ignored. An empty string becomes 0. An error gives NaN.


//////////////////////////////////////////////////////////////


ToBoolean – Occurs in logical operations. Can be performed with Boolean(value).
Value	                        Becomes…
0, null, undefined, NaN, ""	  false
any other value	              true


//////////////////////////////////////////////////////////////


"" + 1 + 0 // '10' ok
"" - 1 + 0 // -1 ok
true + false // 1 ok
6 / "3" // 2 ok
"2" * "3" // 6 ok
4 + 5 + "px" // '9px' ok
"$" + 4 + 5 // '$45' ok
"4" - 2 // 2 ok
"4px" - 2 // NAN ok
7 / 0 // infinity ok
"  -9  " + 5 // ' -9 5' ok
"  -9  " - 5 // -14 ok
null + 1 // 1 (null becomes 0)
undefined + 1 // NAN (undefined becomes NAN)




//////////////////////////////////////////////////////////////

When comparing values of different types, JavaScript converts the values to numbers.

For example:

alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1


For boolean values, true becomes 1 and false becomes 0.

For example:

alert( true == 1 ); // true
alert( false == 0 ); // true

//////////////////////////////////////////////////////////////



It is possible that at the same time:

Two values are equal.
One of them is true as a boolean and the other one is false as a boolean.
For example:

 let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!




//////////////////////////////////////////////////////////////

What will be the result for these expressions?

5 > 4 // true
"apple" > "pineapple" // false
"2" > "12" // true
undefined == null // true
undefined === null // false
null == "\n0\n" // false
null === +"\n0\n" // false


//////////////////////////////////////////////////////////////


alert - shows a message.
prompt - shows a message asking the user to input text. It returns the text or, if CANCEL or Esc is clicked, null.
confirm - shows a message and waits for the user to press “OK” or “CANCEL”. It returns true for OK and false for CANCEL/Esc.

//////////////////////////////////////////////////////////////

[] + {}
"[object Object]"

[] + []
""

[] + 3
"3"

{} + ""
0

{} + '1'
1

{} + 1
1

"" + 7
"7"

null + {}
"null[object Object]"

null + undefined
NaN

'' + NaN
"NaN"

{} * 2
VM385:1 Uncaught SyntaxError: Unexpected token *

{} -1
-1

[] + 1
"1"

[] - 1
-1





//////////////////////////////////////////////////////////////

What is the code below going to output?

alert( null || 2 || undefined );

The answer is 2, that’s the first truthy value.
 alert( null || 2 || undefined );



//////////////////////////////////////////////////////////////



What will the code below output?

alert( alert(1) || 2 || alert(3) );


The answer: first 1, then 2.

alert( alert(1) || 2 || alert(3) );
The call to alert does not return a value. Or, in other words, it returns undefined.

The first OR || evaluates it’s left operand alert(1). That shows the first message with 1.
The alert returns undefined, so OR goes on to the second operand searching for a truthy value.
The second operand 2 is truthy, so the execution is halted, 2 is returned and then shown by the outer alert.
There will be no 3, because the evaluation does not reach alert(3).





//////////////////////////////////////////////////////////////


What is this code going to show?

alert( 1 && null && 2 );


What will this code show?

alert( alert(1) && alert(2) );


//////////////////////////////////////////////////////////////


What will the result be?

alert( null || 2 && 3 || 4 ); // 3


//////////////////////////////////////////////////////////////

Cloning objects - iteration

let user = {
  name: "John",
  age: 30
};


let clone = {};

for (let key in user) {
  clone[key] = user[key];
}

//////////////////////////////////////////////////////////////

Cloning objects - Object.assign

let user = { name: "John" };

let permissions1 = { canView: true, other: false };
let permissions2 = { canEdit: true };
undefined
Object.assign(user, permissions1, permissions2);


//////////////////////////////////////////////////////////////


We also can use Object.assign to replace the loop for simple cloning:

let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);

It copies all properties of user into the empty object and returns it. Actually, the same as the loop, but shorter.

//////////////////////////////////////////////////////////////

// Write the code, one line for each action:

// Create an empty object user.
// Add the property name with the value John.
// Add the property surname with the value Smith.
// Change the value of the name to Pete.
// Remove the property name from the object.

let user = {};
user.name = 'John';
user.surname = 'Smith';
user.name = 'Pete';
delete user.name;


//////////////////////////////////////////////////////////////


Write the function isEmpty(obj) which returns true if the object has no properties, false otherwise.

let schedule = {};

function isEmpty(obj) {
  let k = 0;
  for (let key in obj) {
    k++;
  }

  return k === 0 ? true : false;
}
console.log(isEmpty(schedule));

// or

function isEmpty(obj) {
  for (let key in obj) {
    // if the loop has started, there is a property
    return false;
  }
  return true;
}


//////////////////////////////////////////////////////////////


let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}

let sum = 0;
for (let key in salaries) {
  sum += salaries[key];
}
console.log(sum);


//////////////////////////////////////////////////////////////


Symbols are guaranteed to be unique. Even if we create many symbols with the same description, they are different values. The description is just a label that doesn’t affect anything.

let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false


//////////////////////////////////////////////////////////////

Symbols allow us to create “hidden” properties of an object, that no other part of code can occasionally access or overwrite.

Most values in JavaScript support implicit conversion to a string. For instance, we can alert almost any value, and it will work. Symbols are special. They don’t auto-convert.

For instance, this alert will show an error:

 
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string

If we really want to show a symbol, we need to call .toString() on it, like here:

let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works

Or get symbol.description property to get the description only:

 

let id = Symbol("id");
alert(id.description); // id



//////////////////////////////////////////////////////////////

// without 'use strict'
console.log(this); // window object

function foo() {
 console.log(this);
}
foo(); window object


'use strict'

console.log(this); // window object

function foo() {
 console.log(this);
}
foo(); // undefined
